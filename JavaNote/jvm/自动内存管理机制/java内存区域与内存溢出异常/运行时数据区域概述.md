# JVM 之运行时数据区域概述

## 概述
java 虚拟机 JVM 在执行java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。

这些区域都有各自的用途，创建和销毁的时间。下述内容将依次进行介绍。

## 程序计数器

程序计数器  `Program Counter Register` 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 **行号指示器**

在虚拟机的概念模型内，字节码解释器工作时就是通过改变这个计数器的值，来选取下一条要执行的字节码指令

因为 JVM 的多线程机制 ( 线程轮流切换，分配处理器时间片 ) ，在任何确定的时刻，一个处理器都只会执行一条线程的指令

所以每个线程都需要在自己内部维护一个独立的程序计数器，这部分所占据的内存空间我们称为 “ 线程私有 ” 的内存

### `Tips of Program Counter Register`

如果当前线程执行的是一个 Java 方法，那么这个程序计数器记录的是正在执行的虚拟机字节码指令的地址

如果当前线程执行的是一个 Native 方法，这个计数器的值为空 ( `Undefined` ) 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域

## java 虚拟机栈
java 虚拟机栈 ` Java Virtual Machine Stacks ` 也是线程私有的，生命周期跟随线程。

虚拟机栈描述的是 Java 方法执行的内存模型：

**每个方法在执行的同时都会创建一个栈帧 ` Stack Frame ` ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息**

每一个方法从调用到执行完成的过程，都对应着一个**栈帧**在虚拟机栈中入栈到出栈的过程

栈帧 —— 方法运行时的基础数据结构

Java 虚拟机规范在这个区域内规定了两种异常状况：

- 如果线程请求的栈深度大于虚拟机栈允许的栈深度，将抛出 `StackOverflowError` 异常
- 如果虚拟机栈允许动态扩展，但是在扩展时无法申请到足够的内存，将抛出 ` OutOfMemoryError ` 异常

### 局部变量表

局部变量表内存放了编译期可知的各种数据类型、对象引用、`returnAddress` 类型

### `Tips of Local variable table`

对象引用 ——  ` Reference ` 类型，它不同于对象本身，可能是一个**指向对象起始地址的指针**，也可能是指向一个**代表对象的句柄**或其他与此对象相关的位置

## 本地方法栈

本地方法栈 ( `Native Method Stack` ) 与虚拟机栈有极其相似的作用，他们之间的区别只不过是：
- 虚拟机栈为虚拟机执行 **Java 方法** ( 字节码 ) 服务
- 本地方法栈为虚拟机使用到的 **Native 方法**服务

同样的，本地方法栈也会抛出 `StackOverflowError` 异常和  ` OutOfMemoryError `  异常

## java 堆

## 方法区

## 运行时常量池

## 直接内存